## 객체지향 개념


-----
## 1. 상속

 1 ) 기존의 클래스를 재사용하여 새로운 클르스를 작성하는것 ( 부모와 자식관계)
 
 2 ) 특징 :
 * 자손은 조상의 모든 멤버를 상속받는다 ( 생성자 , 초기화블럭 x)
 * 조상 변경시 자손에게 자동영향 ( 자손 변경시 영향있음 )
 * 자손 클래스의 멤버수 >= 조상 ( 자손클래스 멤버수 = 자손 + 조상 )
 * 자손 객체 생성시 , 자손+조상이 합쳐진 객체로 생성됨

 ▶ 작성방법 :  클래스 자식클래스 이름 extends 부모클래스 이름  →  class Child extends Parent  
 
 -----
 ## 2. 포함관계
 
 1 ) 클래스의 멤버로 다른 타입의 참조변수를 선언
 
 2 ) 특징 : 작은단위의 클래스를 작성, 조합하여 큰단위의 클래스를 생성
 
 3 ) 클래스 간의 관계 설정 방법
 
  * 상속 : ~ 은 ~ 이다 ( is - a ) SportsCar extends Car { }
  * 포함 : ~ 은 ~ 을 가지고 있다 ( has - a ) Point c = new Point()  // 대체로 90%가 '포함'관계
 -----
 
 ## 3. 단일상속
 Java 에서는 단일 상속화만 가능하다
 
 비중이 높은 클래스 하나만 상속관계 , 나머지는 포함관계로 한다
 
 ex)
 
  class TVCR extends TV , VCR  //  에러 , 조상은 하나만 허용한다
 
     class TVCR extends TV {   // 상속
     
     VCR v = new VCR();         // 포함
     
     void play ( ) {            // 포함 , 메서드의 선언부를 동일하게 작성 해야함 
     
     v.play();
     
        }
     
     }
     외부적으로는 TVCR의 메서드를 호출 ,  내부적으로는 VCR의 객체를 생성하고 VCR 의  메서드를 호출했다.  

 
 -----
 
## 3. Object 클래스 

  ✔ 모든 클래스의 조상
  
  ✔ 상속계층도의 최상위에 있는 조상클래스
  
  ✔ 상속받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받는다
  
 
 ▶ Tv클래스가 있고 , Tv클래스를 상속받는 CaptionTV가 있을때의 상속계층도
 

     class Tv { 
         .....
        }
      class Caption Tv expends Tv { 
             ....
          }
  
  ![화면 캡처 2023-02-21 193528](https://user-images.githubusercontent.com/86302876/220321675-50cdd5e1-2e9b-435d-b8a8-a2ed16c5b07c.jpg)

-----
## 4. 오버라이딩  overriding

 1 ) 상속받은 조상메서드의 내용을 변경하는 것
 
 2 ) 조건 :
  * 조상과의 선언부가 같아야한다 - 이름, 매개변수 , 반환타입
  * 접근 제어자를 조상클래스 메서드보다 좁은범위로 변경불가
  * 예외는 조상클래스의 메서드보다 많이 선언할수 없다
  * 인스턴스메서드를 static메서드로 , 또는 static메서드를 인스턴스 메서드로 변경할수 없다
  
3 ) 오버로딩 vs 오버라이딩

  오버로딩은 기존에 없는 새로운 메서드를 추가하는것
  오버라이딩은 조상으로받은 메서드의 내용을 변경하는것
  
  -----
 ## 5. super 
 
 1 ) 객체 자신을 가리키는 참조변수 ( 조상과 자손 의 멤버를 구별하기 위해 쓰임 )
 
 2 ) 특징 : 인스턴스 ( 생성자 ) 내에서만 존재함
 
 3 ) 작성방법 :
    super.x 는 조상클래스로부터 받은 멤버변수 x
    this.x 는 자손클래스에 선언된 멤버변수 x
    조상클래스의 메서드를 자손클래스에서 오버라이딩하는 경우 super 사용
            
     class Point {
     int x ;
     int y;
     String getLocation() {
     return "x :"+x+ ", y :" +y;
       }
     }
     
     class Point3D extends Point {
     int z;
     String getLocation() {
     return super.getLocation() + ",z:" + z;
    }
    
 -----
 
 ## 6. super ( )
 
1 ) 조상 클래스의 멤버를 초기화 하기위한 생성자 

2 ) 모든 생성자의 첫줄에는 this( ) 혹은 super( ) 삽입   // 미삽입시 컴파일러가 자동으로 super( ) 자동추가
   
----- 
    
## 7. 패키지
1 ) 서로 관련된 클래스의 묶음

2 )
* 클래스 = 클래스 파일
* 패키지 = 폴더
* 하위패키지 = 하위 폴더
 
3 ) 클래스의 실제 이름은 패키지를 포함 

4 ) 선언 방법  →  package 패키지이름;

5 ) 특징
  * 같은 소스 파일의 클래스들은 모두 같은 패키지에 속한다
  * 패키지 선언이 없다면 이름없는 패키지에 속한다
  * 클래스 패스 ( 환경변수 ) : 클래스파일 위치를 알려주는 경로 
  * 환경변수(CLASSPATH) 로 관리하며 경로간 구분은 ';' 사용
 -----
 
 ## 8. import문
 
 1 ) 패키지를 사용 할떄 패키지 이름을 생략 할수 있다
 
 2 ) 컴파일러에게 클래스가 속한 패키지를 알려준다
 
 3 ) 작성방법 : 
  ✔ import 패키지이름. 클래스이름;
  
  ✔ import 패키지이름.*  ( * 은 모든 클래스를 뜻함)
  
  ✔ 단축키 : ctrl + shift + o
 
  4 ) static import문 
  
   ▶ static 멤버를 사용할 때 클래스 이름을 생략할수 있게 해줌
   
   
 -----
 

## 9. 제어자

1 ) 클래스와 클래스의 멤버 ( 멤버변수, 메서드 )에 부가적인 의미를 부여함

▪ 접근제어자 : public , protected , default , private

▪ 그외 제어자 : static , final , abstract

✔ 접근제어자는 4가지 종류중 1가지만 사용가능

2 ) static - 클래스의 , 공통적인

* 클래스의 변수
* 클래스의 메서드

✔ 객체 생성 x , iv 사용 x , 인스턴스메서드 사용 x

3 ) flnal - 마지막의 , 변경될수 없는
▪ 변수 → 상수
▪ 메서드 → 오버라이딩 x
▪ 클래스 → 상속 x

4 ) abstract - 추상의 , 미완성의

* 클래스 - 클래스 안에 추상메서드가 있음 ( 미완성 설계도를 뜻함 )
* 메서드 - 선언부만 있고 {  구현부 }가 없음
 
✔ 추상클래스는 객체를 생성불가

5 ) 접근제어자

* private - 같은 클래스 내에서만 접근 간능
* (defaule) - 같은 패키지내에서만 접근가능
* protected - 같은 패키지 내에서 + 다른패키지 자손 클래스에서만 접근가능
* public - 접근 제한 없음

![화면 캡처 2023-02-21 190517](https://user-images.githubusercontent.com/86302876/220314193-0e3dc6b4-1e12-4cdb-a8f7-3bf139953204.jpg)

6 ) 캡슐화와 접근제어자

▶ 접근제어자 사용하는 이유 
* 외부로부터 데이터를 보호하기 위해서
* 외부에는 불필요한 내부적으로만 사용되는 부분을 감추기 위해

▶ 접근제어자를 이용한 캡슐화
* private을 이용하여 변수 직접 접근 불허
* 메서드를 통한 간접 접근 허용 ( if 문으로 값을보호 )

▶ 접근범위 :
public (접근제한 없음) > protected ( 같은패키지+ 자손) > (default) ( 같은 패키지 ) > private ( 같은 클래스 ) 

-----


